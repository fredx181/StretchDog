#!/bin/sh
### linuxc script by fanthom <http://www.porteus.org>

export PATH=/bin:/usr/bin:./

# Enable pivot_root in initramfs to let it behave like initrd:
if [ -d /m ]; then
    mount -nt tmpfs tmpfs -o mode=0755 /m
    cp -a ??* /m 2>/dev/null
    exec switch_root /m linuxrc "$@"
fi

mount -nt proc proc /proc
mount -nt sysfs sysfs /sys
echo 0 >/proc/sys/kernel/printk

clear
echo "[1m""Starting init script ""[0m"

# Functions:
echo "`cat /proc/cmdline|sed -e 's/^/ /'`" > /etc/cmdline
param() { egrep -qo " $1( |\$)" /etc/cmdline; }
value() { egrep -o " $1=[^ ]+" /etc/cmdline | cut -d= -f2; }
debug() { param debug && { echo -e "\n=====\n: Debugging started. Here is the shell for you.\n: Type your desired commands, hit Ctrl+D to continue booting\n: or press Ctrl+Alt+Del to reboot."; sh; echo -e "\n\n"; }; }

# Variables:
i=`echo "[1;33m""^ ""[0m"`
m=`echo "[1;33m""->""[0m"`
arch=`uname -m`; [ $arch = x86_64 ] || arch=i486
DELAY=`value delay`; [ $DELAY ] && { echo $i"delaying $DELAY sec (waiting for slow devices to settle up)"; sleep $DELAY; }
SGN=`value sgnfile`; [ $SGN ] || SGN=initrd1.xz
FROM=`value from`; ISO=`echo $FROM | egrep ".*\.iso( |\$)"`
IP=`value ip | cut -d: -f2`
MOPT=`value mopt`; [ $MOPT ] || MOPT="noatime,nodiratime,suid,dev,exec,async"
CHANGES=`value changes`
RAMSIZE=`value ramsize`; [ $RAMSIZE ] || RAMSIZE=60%
LOAD=`value load | sed 's/;/|/g'`; [ $LOAD ] || LOAD=._null
NOLOAD=`value noload | sed 's/;/|/g'`; [ $NOLOAD ] || NOLOAD=._null
EXTRAMOD=`value extramod | sed 's/;/ /g'`
RAMMOD=`value rammod | sed 's/;/|/g'`
ROOTCOPY=`value rootcopy`
FOLDER=live
livedbg=/var/log/livedbg

# Device Functions:
fstab() { rm -f /tmp/devices
param nocd || for x in /dev/sr*; do blkid $x >>/tmp/devices; done
param nohd || blkid | egrep -v '/dev/sr|/dev/loop|/dev/mapper' >>/tmp/devices
dev=`egrep -v 'TYPE="sw|TYPE="LVM|TYPE=".*_raid_member"' /tmp/devices 2>/dev/null | cut -d: -f1 | cut -d/ -f3 | sort | uniq`
cat > /etc/fstab << EOF
# Do not edit this file as fstab is recreated automatically during every boot.
# Please use /etc/rc.d/rc.local or sysvinit scripts if you want to mount/unmount
# drive, filesystem or network share.

# System mounts:
aufs / aufs defaults 0 0
proc /proc proc defaults 0 0
sysfs /sys sysfs defaults 0 0
devtmpfs /dev devtmpfs defaults 0 0
devpts /dev/pts devpts rw,mode=0620,gid=5 0 0

# Device partitions:
EOF
for x in $dev; do
    fs=`grep -w /dev/$x /tmp/devices | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
    [ $fs = vfat ] && echo "/dev/$x /mnt/$x $fs $MOPT,umask=0,check=s,utf8 0 0" >>/etc/fstab || echo "/dev/$x /mnt/$x $fs $MOPT 0 0" >>/etc/fstab
    if [ ! -d /mnt/$x ]; then
	mkdir /mnt/$x
	if [ $fs = ntfs ]; then
	    ntfs-3g /dev/$x /mnt/$x -o $MOPT 2>/dev/null || { sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x; }
	else
	    mount -n /mnt/$x 2>/dev/null || { modprobe $fs 2>/dev/null && mount -n /mnt/$x 2>/dev/null || { sed -i "/$x /d" /etc/fstab; rmdir /mnt/$x; }; }
	fi
    fi
done

if [ -z "`egrep -o " noswap( |\$)" /etc/cmdline`" -a -e /tmp/devices ]; then
	echo -e "\n# Swap partitions:" >>/etc/fstab
	for x in `grep 'TYPE="swap"' /tmp/devices | cut -d: -f1`; do echo "$x none swap sw,pri=1 0 0" >>/etc/fstab; done
fi }
mount_device() {
fs=`blkid /dev/$1 | egrep -o ' TYPE=[^ ]+' | cut -d'"' -f2`
if [ "$fs" ]; then
    mkdir /mnt/$1
    if [ $fs = vfat ]; then
	mount -n /dev/$1 /mnt/$1 -o $MOPT,umask=0,check=s,utf8 2>/dev/null || rmdir /mnt/$1
    elif [ $fs = ntfs ]; then
	ntfs-3g /dev/$1 /mnt/$1 -o $MOPT 2>/dev/null || rmdir /mnt/$1
    else
	mount -n /dev/$1 /mnt/$1 -o $MOPT 2>/dev/null || { modprobe $fs 2>/dev/null && mount -n /dev/$1 /mnt/$1 -o $MOPT || rmdir /mnt/$1; }
    fi
fi }

# Search functions:
search() { FND=none; for x in `ls /mnt`; do
[ $1 /mnt/$x/$2 ] && { DEV=$x; FND=y; break; }; done
[ $FND = y ]; }
lazy() { SLEEP=6; while [ $SLEEP -gt 0 -a $FND = none ]; do nap; let SLEEP=SLEEP-1; fstab; search $*; done }
locate() { LPATH=`echo $2 | cut -b-5 | sed s@/dev@/mnt@`
if [ $LPATH = /mnt/ ]; then
    DEV=`echo $2 | cut -d/ -f3`; LPTH=`echo $2 | cut -d/ -f4-`; SLEEP=6
    while [ $SLEEP -gt 0 -a ! -b /dev/$DEV ]; do nap; let SLEEP=SLEEP-1; fstab; done
    [ -d /mnt/$DEV ] || mount_device $DEV
    [ $1 /mnt/$DEV/$LPTH ]
elif [ $LPATH = UUID: -o $LPATH = LABEL ]; then
    ID=`echo $2 | cut -d: -f2 | cut -d/ -f1`; LPTH=`echo $2 | cut -d/ -f2-`; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; SLEEP=6
    while [ $SLEEP -gt 0 -a "$DEV" = "" ]; do nap; let SLEEP=SLEEP-1; fstab; DEV=`blkid | grep $ID | cut -d: -f1 | cut -d/ -f3`; done
    [ -d /mnt/$DEV ] || mount_device $DEV
    [ $1 /mnt/$DEV/$LPTH ]
else
    LPTH=$2; search $* || lazy $*
fi }

# Other functions:
nap() { echo -en $i"device not ready yet? delaying [1;33m$SLEEP[0m seconds \r"; sleep 1; }
fail() { echo -e $i"couldn't find $1. Correct your cheatcodes if needed.\n  Press 'enter' to continue booting."; read -s; }
fail_chn() { mount -nt tmpfs -o size=$RAMSIZE tmpfs /memory/changes; CHANGES=memory; CHNDEV=memory; touch /etc/nochanges; }
draw() { echo "[1;33m""---------------------------------------------------------""[0m"; }
fsck_dat() { echo $i"checking $1 for errors"
fs=`blkid $1 | egrep -o ' TYPE=[^ ]+' | cut -b8-10`
if [ $fs = xfs ]; then
    echo $i"detected xfs - performing fsck at mount time"
elif [ $fs = ext ]; then
    draw; e2fsck -C 0 -p $1; wait; draw
elif [ $fs = rei ]; then
    draw; reiserfsck -p $1; wait; draw
else
    echo $i"detected unsupported fs - skipping fsck"
fi }
cpmod() { NUM=`grep -c '.' $1`
for x in `cat $1`; do
    echo -en "[1;33m""  ($NUM modules left)  \r""[0m"; let NUM=NUM-1; NAME=`basename $x`
    cp $x /memory/copy2ram 2>/dev/null
    if [ $? -eq 0 ]; then
	sed -i s@^.*/$NAME@/memory/copy2ram/$NAME@ /tmp/modules
    else
	rm /memory/copy2ram/$NAME; echo -e $i"[1;36m""Not enough memory to copy $NAME""[0m"; echo -e $i"[1;36m""Other modules will be skipped.""[0m"
	find /memory/copy2ram -name "*.squashfs" | sort -u >/tmp/modules
	break
    fi
done
echo -en "                       \r"; }

## Let's start!
echo $i"loading kernel modules..."
for MODULE in ablk_helper aes_i586 aes_x86_64 ahci amd64_edac_mod arc4 ata_generic ata_piix aufs brd button cb710 cb710_mmc cciss cdrom crc16 crc32c_generic crc32_generic crc_itu_t cryptd crypto_simd DAC960 dm_mod dns_resolver drm drm_kms_helper ecb edac_core edac_mce_amd ehci_hcd ehci_pci exportfs ext2 ext4 f2fs fat fb_sys_fops ff_memless firewire_core firewire_ohci fscache fscrypto fuse gf128mulv gpio_generic grace hfs hfsplus hid hid_generic hid_keytouch hid_logitech hid_ortek hid_primax hid_roccat hid_roccat_arvo hid_roccat_common hid_roccat_isku hid_roccat_lua hid_roccat_ryos hid_roccat_savu hid_samsung hid_sunplus i2c_algo_bit i2c_hid ip6_udp_tunnel irqbypass isofs jbd2 joydev kms_helper kvm libahci libata libcrc32c libphy lockd loop lrw mbcache mmc_block mmc_core mptsas mptscsih mptspi mtip32xx mxm_wmi nbd nfnetlink nfs nfsv3 nfsv4 nf_tables nls_ascii nls_cp437 nls_iso8859_1 nls_utf8 ntfs nvme nvme_core ohci_hcd parport pata_acpi pata_ali pata_amd pata_artop pata_atiixp pata_atp867x pata_cmd64x pata_cs5536 pata_efar pata_hpt366 pata_hpt37x pata_it8213 pata_it821x pata_jmicron pata_marvell pata_mpiix pata_netcell pata_ns87410 pata_ns87415 pata_oldpiix pata_opti pata_pcmcia pata_pdc2027x pata_pdc202xx_old pata_rdc pata_rz1000 pata_sch pata_serverworks pata_sil680 pata_sis pata_triflex pata_via pcmcia pcmcia_core pcmcia_rsrc pdc_adma pppox pps_core psmouse ptp raid6_pq reiserfs rng_core sata_mv sata_nv sata_promise sata_qstor sata_sil sata_sil24 sata_sis sata_svw sata_sx4 sata_uli sata_via sata_vsc scsi_mod scsi_transport_fc scsi_transport_sas scsi_transport_spi sdhci sdhci_acpi sdhci_pci sdhci_pltfm sdio_uart sd_mod sdricoh_cs sg soundcore squashfs sr_mod sunrpc sx8 syscopyarea sysfillrect sysimgblt tg3 thermal tifm_core tifm_sd tpm tpm_infineon tpm_tis tpm_tis_core uas udf udp_tunnel ufshcd uhci_hcd uio ums_alauda ums_datafab ums_eneub6250 ums_freecom ums_isd200 ums_jumpshot ums_realtek ums_sddr09 ums_sddr55 ums_usbat usb_common usbcore usbhid usb_storage vfat via_sdmmc vub300 wbsd wmi wmi_bmof xfs xhci_hcd xhci_pci xor xts xxhash zstd_decompress; do
      modprobe $MODULE 2> /dev/null
done

mount -nt devtmpfs none /dev

# Perform filesystem check:
if param fsck; then
    echo $i"performing linux filesystem check on all available devices:"
    draw
    for x in `blkid | grep 'TYPE="ext' | cut -d: -f1`; do e2fsck -C 0 -p $x; wait; done
    for x in `blkid | grep 'TYPE="reiserfs"' | cut -d: -f1`; do reiserfsck -p $x; wait; done
    draw
fi

# Create /etc/fstab and mount devices:
fstab

debug
# Find *.sgn file:
echo $i"searching for $SGN file"
if [ $IP ]; then BOOTDEV=network; SGNDEV=/mnt/nfs
    for x in `lspci | grep 0200: | cut -d: -f3-4 | sed s/:/.*/g | tr a-z A-Z`; do modprobe `grep $x /lib/modules/$(uname -r)/modules.alias | tail -n1 | rev | cut -d" " -f1 | rev` 2>/dev/null; done
    ls /sys/class/net | grep -q eth || { for x in `find /lib/modules/$(uname -r)/kernel/drivers/net -name "*.ko" | sed 's/.ko//g'`; do modprobe `basename $x` 2>/dev/null; ls /sys/class/net | grep -q eth && break || modprobe -r `basename $x` 2>/dev/null; done; }
    mkdir -p /mnt/nfs/porteus /mnt/nfs/storage; udhcpc; modprobe nfsv4; mount -t nfs4 $IP:/srv/pxe/porteus /mnt/nfs/porteus -o ro,nolock 2>/dev/null || { modprobe nfsv3; mount -t nfs $IP:/srv/pxe/porteus /mnt/nfs/porteus -o ro,nolock 2>/dev/null; }
    MAC=`ifconfig | grep eth0 | cut -d: -f5-7 | sed s/://g | cut -d" " -f1`
    if [ "$CHANGES" = /srv/pxe/storage ]; then
	if lsmod | grep -q nfsv3; then
	    mount -t nfs $IP:/srv/pxe/storage /mnt/nfs/storage -o rw,nolock 2>/dev/null && { mkdir -p /mnt/nfs/storage/client-$MAC/changes/home; CHANGES="/storage/client-$MAC"; }
	else
	    mount -t nfs4 $IP:/srv/pxe/storage /mnt/nfs/storage -o rw,nolock 2>/dev/null && { mkdir -p /mnt/nfs/storage/client-$MAC/changes/home; CHANGES="/storage/client-$MAC"; }
	fi
    fi
elif [ $ISO ]; then SGNDEV=/mnt/isoloop
    locate -e $FROM && { BOOTDEV=/mnt/$DEV; mkdir /mnt/isoloop; mount -o loop /mnt/$DEV/$LPTH /mnt/isoloop; }
else
    if [ $FROM ]; then
	locate -e $FROM/live/$SGN
	if [ $? -eq 0 ]; then
	    DIR=`echo $LPTH | rev | cut -d/ -f3- | rev`; [ $DIR ] && FOLDER=$DIR/live
	else
	    echo $i"from= cheatcode is incorrect, press enter to search through all devices"
	    read -s; search -e live/$SGN
	fi
    else
	search -e live/$SGN || lazy -e live/$SGN
    fi
    SGNDEV=/mnt/$DEV
fi

[ -e $SGNDEV/$FOLDER/$SGN ] && PTH=$SGNDEV/$FOLDER || . fatal
echo $i"using data from $PTH"
echo  $PTH > /etc/homedrv
# Make all drivers available:
#mount -o loop $PTH/base/000-kernel.xzm /porteus 2>/dev/null
#mount -o bind /opt/000-kernel/lib/modules /lib/modules 2>/dev/null

# Create symlinks used often by porteus scripts:
ln -sf $PTH/modules  /porteus/modules
ln -sf $PTH/optional /porteus/optional

debug
# Setup changes:
if [ $CHANGES ]; then
    echo $i"setting up directory for changes"
    CHNEXIT=`echo $CHANGES | cut -d: -f1`; [ $CHNEXIT = EXIT ] && CHANGES=`echo $CHANGES | cut -d: -f2-`
    locate -r $CHANGES
    if [ $? -eq 0 ]; then
	if [ -d /mnt/$DEV/$LPTH ]; then
	    mkdir -p /mnt/$DEV/$LPTH/changes 2>/dev/null && \
	    mount -o bind /mnt/$DEV/$LPTH/changes /memory/changes && touch /memory/changes/._test1 2>/dev/null
	else
	    if blkid /mnt/$DEV/$LPTH 2>/dev/null | cut -d" " -f3- | grep -q _LUKS; then
		for x in dm_crypt cryptd cbc sha256_generic aes_generic aes_x86_64; do modprobe $x 2>/dev/null; done
		losetup /dev/loop2 /mnt/$DEV/$LPTH

		echo $i"found encrypted .dat container"
		cryptsetup luksOpen /dev/loop2 crypt
		fsck_dat /dev/mapper/crypt
		mount /dev/mapper/crypt /memory/changes 2>/dev/null && touch /memory/changes/._test1 2>/dev/null
	    else
		fsck_dat /mnt/$DEV/$LPTH
		mount -o loop /mnt/$DEV/$LPTH /memory/changes 2>/dev/null && touch /memory/changes/._test1 2>/dev/null
	    fi
	fi
	if [ $? -eq 0 ]; then
	    echo $i"testing filesystem on "$CHANGES" for posix compatibility"
	    ln -s /memory/changes/._test1 /memory/changes/._test2 2>/dev/null && chmod +x /memory/changes/._test1 2>/dev/null && [ -x /memory/changes/._test1 ] && chmod -x /memory/changes/._test1 2>/dev/null && [ ! -x /memory/changes/._test1 ] && rm -f /memory/changes/._test1 /memory/changes/._test2
	    if [ $? -ne 0 ]; then
		rm -f /memory/changes/._test1 /memory/changes/._test2; umount /memory/changes
		echo && echo -e "[1;33m""A Windows filesystem (FAT, NTFS) or other non-posix compatible filesystem\nhas been detected on $CHANGES.\nYour changes cannot be saved directly to the specified storage media with this\nsetup. Please use the '[1;36mPorteus save file manager[1;33m' to create a .dat container\nand use it for saving your changes after your next reboot.""[0m"
		echo "press enter to continue in '[1;36mAlways Fresh[0m' mode for this session"
		read; rmdir /mnt/$DEV/$LPTH/changes; fail_chn
	    else
		echo $i"filesystem is posix compatible"; CHNDEV=/mnt/$DEV
		rmdir /memory/changes/mnt/* 2>/dev/null
		rm -f /memory/changes/var/lock/subsys/* /var/run/laptop-mode-tools/*
		for x in `find /memory/changes/var/run -name "*pid" 2>/dev/null`; do rm $x; done
#        if [ -f /mnt/$DEV/$LPTH/changes/clear-changes-on-reboot ]; then
        if [ -f /memory/changes/clear-changes-on-reboot ]; then
                      echo $i"[1;36m""changes content signalled to be cleared""[0m"
#                      rm -rf /mnt/$DEV/$LPTH/changes/*
#		rm -rf /mnt/$DEV/$LPTH/changes/.wh*
                      rm -rf /memory/changes/*
		rm -rf /memory/changes/.wh*

	fi
		if [ $CHNEXIT = EXIT ]; then
		    CHNEXIT=$CHNDEV/$LPTH; echo $CHNEXIT >/tmp/changes-exit
		    echo $i"[1;36m""changes will be saved only during reboot/shutdown""[0m"
		    #for x in `find /memory/changes -name ".wh.*"`; do cp -a --parents $x /var; done
#		    find /memory/changes  -name ".wh.*" | while IFS= read -r NAME; do cp -a --parents "$NAME" /var; done
		    umount /memory/changes; mount -nt tmpfs -o size=$RAMSIZE tmpfs /memory/changes
		    # need to fix busybox bug on 'cp -a' as it does not preserve perms on dirs:
#		    chown -R 1000:1000 /var/memory/changes/home/guest 2>/dev/null
#		    mv /var/memory/changes/* /memory/changes 2>/dev/null; CHANGES=memory
		fi
	    fi
	else
	    echo $i"changes not writable, using memory instead"; umount /memory/changes 2>/dev/null; fail_chn
	fi
    else
	fail $CHANGES; fail_chn
    fi
else
     echo $i"changes cheatcode not found, using memory only"; fail_chn
fi

mkdir -p /memory/changes/mnt/live

debug
# Setup aufs:
echo $i"creating live filesystem and inserting modules"
mount -t aufs -o nowarn_perm,xino=/memory/xino/.aufs.xino,br:/memory/changes=rw aufs /union
if [ $? -ne 0 ]; then echo -e "[31m""cant setup union (aufs) - read only filesystem?\nWhen you finish debugging press Ctrl+Alt+Del to reboot.""[0m"; sh; fi

# Find modules:
 ls $PTH/*.squashfs 2>/dev/null | egrep -v "$NOLOAD" | sort -u >/tmp/modules
 find $PTH/base $PTH/modules -name "*.squashfs" 2>/dev/null | egrep -v "$NOLOAD" | sort -u >>/tmp/modules
 find $PTH/optional -name "*.squashfs" 2>/dev/null | egrep "$LOAD" | sort >>/tmp/modules

if param vga_detect; then
    echo $i"detecting GPU"
    lspci >/tmp/lspci; nv=`grep "0300: 10de:" /tmp/lspci | cut -d":" -f4`; amd=`grep "0300: 1002:" /tmp/lspci | cut -d":" -f4`
    if [ $nv ]; then
	echo $i"$nv chipset found, checking which nVidia driver supports it"
	cd /usr/share/pciids/nVidia; NV=`grep $nv * | cut -d: -f1`; cd /
	if [ $NV ]; then
	    echo $i"nVidia-$NV.xx driver will be activated -"
	    echo $i"if present in $PTH/optional folder"
	    find $PTH/optional -name "nVidia-$NV*" 2>/dev/null >>/tmp/modules
	else
	    echo $i"latest nVidia driver will be activated -"
	    echo $i"if present in $PTH/optional folder"
	    find $PTH/optional -name "nVidia-*" 2>/dev/null | egrep -v '96.43.|173.14.|304.' >>/tmp/modules
	fi
    elif [ $amd ]; then
	echo $i"checking if $amd GPU belongs to 'Radeon HD' series"
	cd /usr/share/pciids/AMD; HD=`grep $amd * | cut -d: -f1`; cd /
	if [ $HD ]; then
            echo $i"AMD proprietary driver will be activated -"
            echo $i"if present in $PTH/optional folder"
            find $PTH/optional -name "$HD-1*" 2>/dev/null >>/tmp/modules
        else
            echo $i"$amd GPU is not supported by amd-catalyst driver - refusing activation"
        fi
    else
        echo $i"could not find any nVidia/AMD GPU on this PC"
    fi
fi

if param base_only; then
grep live /tmp/modules | grep -v modules > /tmp/mod
 #   grep base/0 /tmp/modules > /tmp/mod
    mv /tmp/mod /tmp/modules
else
    if [ "$EXTRAMOD" ]; then
	for folder in $EXTRAMOD; do
	    echo $i"searching for additional modules in $folder"
	    locate -d $folder && { find /mnt/$DEV/$LPTH -name "*.squashfs" 2>/dev/null | egrep -v "$NOLOAD" | sort >>/tmp/modules; } || fail $folder
	done
    fi
fi

# Copy data to RAM:
if param copy2ram; then
    echo $i"copying data to RAM, this may take some time..."
    [ $RAMMOD ] && { egrep "$RAMMOD" /tmp/modules > /tmp/rammod; cpmod /tmp/rammod; } || cpmod /tmp/modules
fi

# Populate aufs with modules:
umount /lib/modules /opt/000-kernel 2>/dev/null
for x in `cat /tmp/modules`; do
    NAME=`basename $x`; mkdir /memory/images/$NAME; mount -o loop $x /memory/images/$NAME 2>/dev/null
    if [ $? -eq 0 ]; then
	echo "  $m  $NAME"; mount -no remount,add:1:/memory/images/$NAME=rr+wh aufs /union
    else
	echo $i"[1;36m""Cannot read $NAME - corrupted module?""[0m"; rmdir /memory/images/$NAME
    fi
done
mount -no bind /union/lib/modules /lib/modules 2>/dev/null

# Add "changes on exit" device/file/folder:
if [ -e /tmp/changes-exit ]; then
    mkdir /memory/images/changes-exit
    if [ -d $CHNEXIT ]; then
	mount -o bind $CHNEXIT/changes /memory/images/changes-exit
    elif [ -b /dev/mapper/crypt ]; then
	mount /dev/mapper/crypt /memory/images/changes-exit
    else
	mount -o loop $CHNEXIT /memory/images/changes-exit
    fi
    echo "  $m  changes-exit"; mount -no remount,add:1:/memory/images/changes-exit=ro+wh aufs /union
    echo $CHNEXIT/changes >>/tmp/modules
fi

debug
# Copy /rootcopy folder:
if param norootcopy; then
    ROOTCOPY=none
    echo $i"skipping /rootcopy directory"
else
    if [ $ROOTCOPY ]; then
	locate -d $ROOTCOPY
	if [ $? -eq 0 ]; then echo $i"copying content of $ROOTCOPY directory"; cp -af /mnt/$DEV/$LPTH/. /union/. 2>/dev/null; else fail $ROOTCOPY; ROOTCOPY=none; fi
    else
	ROOTCOPY=none
	echo $i"copying content of $PTH/rootcopy directory"
	cp -af $PTH/rootcopy/. /union/. 2>/dev/null
    fi
fi

## Finish:
# Create 7 free loop devices for truecrypt, etc...
x=`losetup | tail -n1 | cut -d: -f1 | sed 's@/dev/loop@@'`; let y=x+255
while [ $x -le $y ]; do [ -b /dev/loop$y ] && break || mknod /dev/loop$y b 7 $y; chmod g+rw-x,o-rwx /dev/loop$y; let y=y-1; done

if param nonetwork; then
    echo $i"disabling dhcpcd and NetworkManager services"
    chmod -x /union/etc/rc.d/rc.inet1 /union/etc/rc.d/rc.networkmanager 2>/dev/null
    nma=/union/etc/xdg/autostart/nm-applet.desktop
    test -e $nma && ! grep -q "Hidden=true" $nma && echo "Hidden=true" >> $nma
fi

if [ "$IP" -a -x /union/etc/rc.d/rc.networkmanager ]; then
    if [ -z "`egrep -o " copy2ram( |\$)" /etc/cmdline`" -o -d /mnt/nfs/storage/client-$MAC ]; then
	echo "nameserver $IP" > /union/etc/resolv.conf
	nmc=/union/etc/NetworkManager/NetworkManager.conf; HW=`ifconfig | grep eth0 | cut -dW -f2 | cut -d" " -f2`
	! grep -q "unmanaged-devices=mac:$HW" $nmc && sed -i '/\[keyfile\]/ a\unmanaged-devices=mac:'$HW'' $nmc
    fi
fi

cp -af /dev/console /union/dev
cat > /union/etc/mtab << EOF
aufs / aufs rw 0 0
proc /proc proc rw 0 0
sysfs /sys sysfs rw 0 0
devtmpfs /dev devtmpfs rw 0 0
devpts /dev/pts devpts rw,mode=0620,gid=5 0 0
EOF
fstab

debug
if param copy2ram; then
    [ $SGNDEV = /mnt/isoloop -o $SGNDEV = /mnt/nfs ] && { umount `grep $SGNDEV /etc/mtab | sed -n 1p | cut -d" " -f2`; SGNDEV=$BOOTDEV; }
    CHNDISK=`echo $CHNDEV | cut -b6-8`; SGNDISK=`echo $SGNDEV | cut -b6-8`; REMOVABLE=`cat /sys/block/$SGNDISK*/removable 2>/dev/null`
    if [ -z "`egrep -o " noeject( |\$)" /etc/cmdline`" -a "$CHNDISK" != "$SGNDISK" ]; then
	if [ "$REMOVABLE" = 1 ]; then
	    for rdisk in `ls /mnt | grep $SGNDISK`; do
		umount -n /mnt/$rdisk 2>/dev/null && rmdir /mnt/$rdisk
		if [ $? -eq 0 ]; then
		    grep -qw "/dev/$rdisk.*iso9660" /etc/fstab && /union/usr/bin/eject /dev/$rdisk
		    sed -i "/$rdisk/d" /etc/fstab
		fi
	    done
	    [ `ls /mnt | grep $SGNDISK` ] || echo $i"[1;36m""finished copying to RAM - booting media can be removed safely""[0m"
	else
	    if param nohd; then umount $SGNDEV 2>/dev/null; rmdir $SGNDEV 2>/dev/null; fi
	fi
    fi
fi

# Create debug file:
[ -e /tmp/devices ] && { echo "# Recognized devices:" >$livedbg; cat /tmp/devices >>$livedbg; }
[ $BOOTDEV ] && SGNDEV=$BOOTDEV
echo -e "\n# Booting device:\n$SGNDEV\n\n#  data found in:\n$PTH\n\n# Changes are stored in:\n$CHANGES\n\n# Non standard /rootcopy dir:\n$ROOTCOPY\n\n# Modules activated during boot time:" >>$livedbg; cat /tmp/modules >>$livedbg

cp -af $livedbg /union/var/log/porteus-livedbg

echo $i"changing root directory"
echo "`cat /proc/cmdline`"
#if param noauto; then
   if grep -q noauto /proc/cmdline; then
nofstab=yes
    for x in `grep /mnt/ /etc/fstab | cut -d/ -f3`; do mkdir -p /union/mnt/$x; umount -n /mnt/$x 2>/dev/null && rmdir /mnt/$x; done
else
    grep /mnt/ /etc/fstab >> /union/etc/mtab
    for x in `grep /mnt/ /etc/fstab | cut -d/ -f3`; do mkdir -p /union/mnt/$x; mount -n --move /mnt/$x /union/mnt/$x; rmdir /mnt/$x; done
fi
#echo $i"Copying files from original debian initrd..."
#echo ...
#cp -a /unioncp/. /union/.
sed -i 's/ ntfs / ntfs-3g /g' /etc/fstab
echo -e "\n# Hotplugged devices:" >> /etc/fstab
if [ $nofstab = "" ]; then
cp -f /etc/fstab /union/etc 2>/dev/null
fi

for MODULE in ablk_helper aes_i586 aes_x86_64 ahci amd64_edac_mod arc4 ata_generic ata_piix aufs brd button cb710 cb710_mmc cciss cdrom crc16 crc32c_generic crc32_generic crc_itu_t cryptd crypto_simd DAC960 dm_mod dns_resolver drm drm_kms_helper ecb edac_core edac_mce_amd ehci_hcd ehci_pci exportfs ext2 ext4 f2fs fat fb_sys_fops ff_memless firewire_core firewire_ohci fscache fscrypto fuse gf128mulv gpio_generic grace hfs hfsplus hid hid_generic hid_keytouch hid_logitech hid_ortek hid_primax hid_roccat hid_roccat_arvo hid_roccat_common hid_roccat_isku hid_roccat_lua hid_roccat_ryos hid_roccat_savu hid_samsung hid_sunplus i2c_algo_bit i2c_hid ip6_udp_tunnel irqbypass isofs jbd2 joydev kms_helper kvm libahci libata libcrc32c libphy lockd loop lrw mbcache mmc_block mmc_core mptsas mptscsih mptspi mtip32xx mxm_wmi nbd nfnetlink nfs nfsv3 nfsv4 nf_tables nls_ascii nls_cp437 nls_iso8859_1 nls_utf8 ntfs nvme nvme_core ohci_hcd parport pata_acpi pata_ali pata_amd pata_artop pata_atiixp pata_atp867x pata_cmd64x pata_cs5536 pata_efar pata_hpt366 pata_hpt37x pata_it8213 pata_it821x pata_jmicron pata_marvell pata_mpiix pata_netcell pata_ns87410 pata_ns87415 pata_oldpiix pata_opti pata_pcmcia pata_pdc2027x pata_pdc202xx_old pata_rdc pata_rz1000 pata_sch pata_serverworks pata_sil680 pata_sis pata_triflex pata_via pcmcia pcmcia_core pcmcia_rsrc pdc_adma pppox pps_core psmouse ptp raid6_pq reiserfs rng_core sata_mv sata_nv sata_promise sata_qstor sata_sil sata_sil24 sata_sis sata_svw sata_sx4 sata_uli sata_via sata_vsc scsi_mod scsi_transport_fc scsi_transport_sas scsi_transport_spi sdhci sdhci_acpi sdhci_pci sdhci_pltfm sdio_uart sd_mod sdricoh_cs sg soundcore squashfs sr_mod sunrpc sx8 syscopyarea sysfillrect sysimgblt tg3 thermal tifm_core tifm_sd tpm tpm_infineon tpm_tis tpm_tis_core uas udf udp_tunnel ufshcd uhci_hcd uio ums_alauda ums_datafab ums_eneub6250 ums_freecom ums_isd200 ums_jumpshot ums_realtek ums_sddr09 ums_sddr55 ums_usbat usb_common usbcore usbhid usb_storage vfat via_sdmmc vub300 wbsd wmi wmi_bmof xfs xhci_hcd xhci_pci xor xts xxhash zstd_decompress; do
      modprobe -r $MODULE 2> /dev/null
done

umount -n /lib/modules 2>/dev/null

rm -r /lib/* /usr/*

debug
echo "[1m""live system is ready now - starting Debian""[0m"
if param init=/bin/systemd; then
	if [ -f /union/lib/systemd/systemd ]; then
cp -f /union/lib/systemd/systemd /bin
		if [ $? -eq 0 ]; then
echo "[1m""using systemd...""[0m"
    pivot_root /union  /union/mnt/live
    exec usr/sbin/chroot . /mnt/live/bin/systemd "$@" <dev/console >dev/console 2>&1
		else
    echo -e "[31m""!!ERROR!!\nSomething went wrong and I cannot continue.\nPress Ctrl+Alt+Del to reboot.""[0m"
    sh  
		fi
	else
 echo "[1m""systemd not found, trying to use initscripts...""[0m" 
cp -f /union/sbin/init /bin
		if [ $? -eq 0 ]; then
    pivot_root /union  /union/mnt/live
    exec usr/sbin/chroot . /mnt/live/bin/init "$@" <dev/console >dev/console 2>&1
		else
    echo -e "[31m""!!ERROR!!\nSomething went wrong and I cannot continue.\nPress Ctrl+Alt+Del to reboot.""[0m"
    sh
		fi
	fi
else
    if [ -L /union/sbin/init ]; then
echo "[1m""/sbin/init appears to be a symlink, assuming systemd-sysv is installed""[0m"
echo "[1m""trying to switch to systemd now...""[0m"
cp -f /union/lib/systemd/systemd /bin
		if [ $? -eq 0 ]; then
echo "[1m""using systemd...""[0m"
    pivot_root /union  /union/mnt/live
    exec usr/sbin/chroot . /mnt/live/bin/systemd "$@" <dev/console >dev/console 2>&1
		else
    echo -e "[31m""!!ERROR!!\nSomething went wrong and I cannot continue.\nPress Ctrl+Alt+Del to reboot.""[0m"
    sh  
		fi
    else
cp -f /union/sbin/init /bin
		if [ $? -eq 0 ]; then
    pivot_root /union  /union/mnt/live
    exec usr/sbin/chroot . /mnt/live/bin/init "$@" <dev/console >dev/console 2>&1
		else
    echo -e "[31m""!!ERROR!!\nSomething went wrong and I cannot continue.\nPress Ctrl+Alt+Del to reboot.""[0m"
    sh
		fi
    fi
fi
